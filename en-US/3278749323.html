<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head xmlns:forms="http://www.schema.de/2010/ST4/Layout/MarkupLanguage/Forms"><meta http-equiv="Content-Script-Type" content="text/javascript" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="generator" content="SCHEMA ST4, Bootstrap 2016 v1" /><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" /><meta name="msapplication-config" content="none" /><link rel="icon" type="image/x-icon" href="../assets/ico/bruker.ico" /><link rel="stylesheet" href="../assets/css/base/01-bootstrap.min.css" /><link rel="stylesheet" href="../assets/css/base/02-jquery-tree.css" /><link rel="stylesheet" href="../assets/css/base/03-bootstrap-schema.css" /><link rel="stylesheet" href="../assets/css/base/04-jquery.mcustomscrollbar.min.css" /><link rel="stylesheet" href="../assets/css/base/05-jquery.mmenu.oncanvas.css" /><link rel="stylesheet" href="../assets/css/base/06-jquery.mmenu.schema.css" /><link rel="stylesheet" href="../assets/css/formats.css" /><title>xfb, ftf</title></head><body id="3278749323" lang="en-US" xmlns:forms="http://www.schema.de/2010/ST4/Layout/MarkupLanguage/Forms" data-node-id="3278749323" class="" data-culture="en-US"><div class="off-canvas"><div id="off-canvas-menu" role="complementary"></div><div id="pushobj"><div class="scroll-container content-container" id="content-container"><div class="container" role="main"><ol class="breadcrumb hidden-xs"><li><a style="color:#3195CA;" href="index.html"></a></li><li><a style="color:#3195CA;" href="3278568587.html">2D Processing Commands</a></li><li>xfb, ftf</li></ol><h1 class="heading" style="color:black;">xfb, ftf</h1><div class="metalist"></div><h2 class="subheading">NAME</h2><p>xfb - <span class=".index-entry" id="ID0ERPWO"></span>Process<span class=".index-entry" id="ID0EUPWO"></span> data, including FT, in F2 and F1 (2D)</p><p>ftf - Open Fourier transform dialog box (1D,2D)</p><h2 class="subheading">DESCRIPTION</h2><p>The command <strong>xfb</strong> processes a 2D dataset or a plane of a dataset with dimension ≥ 3. It can be started from the command line or from the Fourier transform dialog box. The latter is opened with the command <strong>ftf</strong>. </p><p> </p><figure class="img_80"><img src="../Images/png/9007199657150091__en-US__Web.png" width="520" height="468" /></figure><p> </p><p>The <strong>ftf</strong> command recognizes the data dimensionality and opens a dialog box with the appropriate options and parameters. For 2D data, two options appear, both of which select the <strong>xfb</strong> command for execution, provided the F2 and F1 direction are both enabled.</p><p><strong>Standard Fourier transform</strong></p><p>This option only allows to set the parameter SI, the size of the real spectrum. </p><p><strong>Advanced Fourier transform</strong></p><p>This option allows to set all Fourier transform related parameters. </p><p><strong>xfb</strong> <span class=".index-entry" id="ID0EBRWO"></span>Fourier transforms <span class=".index-entry" id="ID0EFRWO"></span>time domain data into <span class=".index-entry" id="ID0EIRWO"></span>frequency domain data. Depending on the processing parameters BC_mod, WDW, ME_mod and PH_mod, <strong>xfb</strong> also performs <span class=".index-entry" id="ID0ENRWO"></span>baseline correction, <span class=".index-entry" id="ID0ERRWO"></span>window multiplication, <span class=".index-entry" id="ID0EVRWO"></span>linear prediction and spectrum <span class=".index-entry" id="ID0EZRWO"></span>phase correction.</p><p>The processing steps done by <strong>xfb</strong> can be described as follows: </p><ol class="list"><li value="1">Baseline correction of the 2D time domain data. Each row and/or column is baseline corrected according to BC_mod. This parameter takes the value <em>no</em>, <em>single</em>, <em>quad</em>, <em>spol</em>, <em>qpol</em> <em>sfil</em> or <em>qfil</em>. More details on BC_mod can be found in chapter List of processing parameters.</li><li value="2">Linear prediction of the 2D time domain data. Linear prediction is done according to ME_mod. This parameter takes the value <em>no</em>, <em>LPfr</em>, <em>LPfc</em>, <em>LPbr</em>, <em>LPbc, LPmifr </em>or<em> LPmifc. </em>Usually, ME_mod = no, which means no prediction is done. Forward prediction (<em>LPfr</em>, <em>LPfc, LPmifr </em>or<em> LPmifc</em>) can, for example, be used to extend <span class=".index-entry" id="ID0EQTWO"></span>truncated FIDs. Backward prediction (<em>LPbr</em> or <em>LPbc</em>) can be used to improve the initial data points of the FID. Linear prediction is only performed for NCOEF &gt; 0. Furthermore, LPBIN and, for backward prediction, TDoff play a role (see these parameters in chapter List of processing parameters).</li><li value="3"><span class=".index-entry" id="ID0E5TWO"></span>Window multiplication of the 2D time domain data. Each row and/or column is multiplied with a window function according to WDW. This parameter takes the value <em>em</em>, <em>gm</em>, <em>sine</em>, <em>qsine</em>, <em>trap</em>, <em>user</em>, <em>sinc</em>, <em>qsinc</em>, <em>traf</em> or <em>trafs</em>. More details on WDW can be found in chapter List of processing parameters.</li><li value="4"><span class=".index-entry" id="ID0E4UWO"></span>Fourier transform of the 2D time domain data. Each row is Fourier transformed according to the acquisition status parameter AQ_mod as shown in the table below. Each column (F1) is Fourier transformed according to the acquisition status parameter FnMODE as shown in the table below. <strong>xfb</strong> does not evaluate the processing parameter FT_mod! However, it stores the Fourier transform mode as it was evaluated from AQ_mod (F2) or FnMODE (F1) in the processing status parameter FT_mod. If, for some reason, you want to Fourier transform a spectrum with a different mode, you can set the processing parameter FT_mod (with <strong>edp</strong>) and use the command <strong>xtrf</strong> (see <strong>xtrf</strong>). More details on FT_mod can be found in chapter List of processing parameters.</li><li value="5">Phase correction of the 2D spectrum according to PH_mod. This parameter takes the value <em>no</em>, <em>pk</em>, <em>mc</em> or <em>ps</em>. For PH_mod = pk, <strong>xfb</strong> applies the values of PHC0 and PHC1. This is only useful if the <span class=".index-entry" id="ID0E2VWO"></span>phase values are known. If they are not, you can do an interactive <span class=".index-entry" id="ID0E6VWO"></span>phase correction in Phase correction mode after <strong>xfb</strong> has finished. More details on PH_mod can be found in chapter List of processing parameters.</li></ol><table class="table tabletype-header table-fixed"><colgroup><col style="width: 33.2%;"></col><col style="width: 33.3%;"></col><col style="width: 33.3%;"></col></colgroup><thead><tr><th><p class="text-left">F2 AQ_mod</p></th><th><p class="text-left"><span class=".index-entry" id="ID0EZWWO"></span>Fourier transform mode</p></th><th><p class="text-left">F2 status FT_mod</p></th></tr></thead><tbody><tr><td><p class="text-left">qf </p>
</td><td><p class="text-left">forward, single, real</p>
</td><td><p class="text-left">fsr</p>
</td></tr><tr><td><p class="text-left">qsim</p>
</td><td><p class="text-left">forward, quad, complex</p>
</td><td><p class="text-left">fqc</p>
</td></tr><tr><td><p class="text-left">qseq </p>
</td><td><p class="text-left">forward, quad, real</p>
</td><td><p class="text-left">fqr</p>
</td></tr><tr><td><p class="text-left">DQD</p>
</td><td><p class="text-left">forward, quad, complex</p>
</td><td><p class="text-left">fqc</p>
</td></tr></tbody></table><table class="table tabletype-header table-fixed"><colgroup><col style="width: 33.3%;"></col><col style="width: 33.3%;"></col><col style="width: 33.3%;"></col></colgroup><thead><tr><th><p class="text-left">F1 FnMODE</p></th><th><p class="text-left"><span class=".index-entry" id="ID0ESZWO"></span>Fourier transform mode</p></th><th><p class="text-left">F1 status FT_mod</p></th></tr></thead><tbody><tr><td><p class="text-left">QF </p>
</td><td><p class="text-left">forward, quad, complex</p>
</td><td><p class="text-left">fqc</p>
</td></tr><tr><td><p class="text-left">QSEQ</p>
</td><td><p class="text-left">forward, quad, real</p>
</td><td><p class="text-left">fqr</p>
</td></tr><tr><td><p class="text-left">TPPI </p>
</td><td><p class="text-left">forward, single, real</p>
</td><td><p class="text-left">fsr</p>
</td></tr><tr><td><p class="text-left">States</p>
</td><td><p class="text-left">forward, quad, complex</p>
</td><td><p class="text-left">fqc</p>
</td></tr><tr><td><p class="text-left">States-TPPI</p>
</td><td><p class="text-left">forward, single, complex</p>
</td><td><p class="text-left">fsc</p>
</td></tr><tr><td><p class="text-left">Echo-AntiEcho</p>
</td><td><p class="text-left">forward, quad, complex</p>
</td><td><p class="text-left">fqc</p>
</td></tr></tbody></table><p> </p><p>The size of the processed data is determined by the processing parameter SI; SI real and SI imaginary points are created. A typical value for SI is TD/2 in which case, all raw data points are used and no <span class=".index-entry" id="ID0EB4WO"></span>zero filling is done. In fact, several parameters control the number of input and output data points, for example:</p><ol class="list"><li value="1">SI &gt; TD/2: the raw data are zero filled before the <span class=".index-entry" id="ID0EK4WO"></span>Fourier transform</li><li value="2">SI &lt; TD/2: only the first 2*SI raw data points are used</li><li value="3">0 &lt; TDeff &lt; TD: only the first TDeff raw data points are used</li><li value="4">0 &lt; TDoff &lt; TD: the first TDoff raw data points are cut off at the beginning and TDoff zeroes are appended at the end (corresponds to left shift).</li><li value="5">TDoff &lt; 0: -TDoff zeroes are prepended at the beginning. Note that:</li><ul class="list"><li value="1">for SI &lt; (TD-TDoff)/2 raw data are cut off at the end</li><li value="2">for DIGMOD=digital, the zeroes would be prepended to the group delay which does not make sense. You can avoid that by converting the raw data with <strong>convdta</strong> before you process them.</li></ul><li value="6">0 &lt; STSR &lt; SI: only the processed data between STSR and STSR+STSI are stored (if STSI = 0, STSR is ignored and SI points are stored)</li><li value="7">0 &lt; STSI &lt; SI: only the processed data between STSR and STSR+STSI are stored.</li></ol><div class="safety safety-type-note safety-severity-note"><div class="safety-header">NOTE</div><div class="safety-body"><div class="row"><div class="col-sm-2 safety-symbol"><img src="../safety/note_NoteIcon.png" /></div><div class="col-sm-10"><p class="safety-consequence">Note that only in the first case the processed data contain the total information of the raw data. In all other cases, information is lost.</p></div></div></div><div class="safety-footer"></div></div><p><strong>xfb</strong> performs a <span class=".index-entry" id="ID0E55WO"></span>quad spike correction which means that the central data point of the spectrum is replaced by the average of the neighbouring data points in the F1 direction. Note that the <span class=".index-entry" id="ID0EB6WO"></span>quad spike correction is skipped if you process the data with the sequence <strong><span class=".index-entry" id="ID0EF6WO"></span>xf2</strong> - <strong><span class=".index-entry" id="ID0EK6WO"></span>xf1</strong>.</p><p><strong>xfb</strong> evaluates the parameter FCOR. The first point of the FIDs is multiplied with the value of FCOR which lies between 0.0 and 2.0. For <span class=".index-entry" id="ID0ES6WO"></span>digitally filtered <span class=".index-entry" id="ID0EV6WO"></span>Avance data, FCOR is only used in the F1 direction. In F2, it has no effect because the first point is part of the group delay and, as such, is zero. However, A*X data or Avance data measured with DIGMOD = analog, FCOR is used in F1 and F2.</p><p><strong>xfb</strong> evaluates the F2 parameter PKNL. On A*X spectrometers, PKNL = true causes a non linear 5th order phase correction of the raw data. This corrects possible errors caused by non linear behaviour of the analog filters. On <span class=".index-entry" id="ID0E46WO"></span>Avance spectrometers, PKNL must always be set to TRUE. For <span class=".index-entry" id="ID0EBAXO"></span>digitally filtered data, it causes <strong>xfb</strong> to handle the <span class=".index-entry" id="ID0EGAXO"></span>group delay of the FID. For analog data it has no effect.</p><p><strong>xfb</strong> evaluates the F2 and F1 parameter REVERSE. If REVERSE = TRUE, the spectrum will be <span class=".index-entry" id="ID0ENAXO"></span>reversed in the corresponding direction, i.e. the first data point becomes the last and the last data point becomes the first. The same effect can be obtained with the commands <strong><span class=".index-entry" id="ID0ESAXO"></span>rev2</strong> and/or <strong><span class=".index-entry" id="ID0EXAXO"></span>rev1</strong> after <strong>xfb</strong>.</p><p><strong>USAGE:</strong></p><p><strong>xfb</strong> is normally used without options. There are, however, several options available:</p><ul class="list"><li value="1"><strong>n</strong> </li><ul class="list"><li value="1"><strong>xfb</strong> normally stores real and <span class=".index-entry" id="ID0ESBXO"></span>imaginary processed data. However, the imaginary data are only needed for phase correction. If the parameters PHC0 and PHC1 are set correctly, then you don’t need to store the imaginary data. The option <strong>n</strong> allows to do that. This will save processing time and <span class=".index-entry" id="ID0EYBXO"></span>disk space. If you still want to do a <span class=".index-entry" id="ID0E2BXO"></span>phase correction, you can create imaginary data from the real data with a <span class=".index-entry" id="ID0E6BXO"></span>Hilbert transform (see <strong>xht2</strong> and <strong>xht1</strong>).</li></ul><li value="2"><strong>nc_proc value</strong> </li><ul class="list"><li value="1"><strong>xfb</strong> scales the data such that, i.e. the highest intensity of the spectrum lies between 2<sup>28</sup> and 2<sup>29</sup>. The <span class=".index-entry" id="ID0EYCXO"></span>intensity scaling factor is stored in the processing status parameter NC_proc and can be viewed with <strong>dpp</strong>. The option <strong>nc_proc</strong> causes <strong>xfb</strong> to use a specific scaling factor. However, you can only scale down the data by entering a greater (more positive) value than the one <strong>xfb</strong> would use without this option. If you enter a smaller (more negative) value, the option will be ignored to prevent <span class=".index-entry" id="ID0EEDXO"></span>data overflow. The option <strong>nc_proc last</strong> causes <strong>xfb</strong> to use the current value of the status processing parameter NC_proc, i.e. the value set by the previous processing step on this dataset. </li></ul><li value="3"><strong>raw/proc</strong> </li><ul class="list"><li value="1"><strong>xfb</strong> works on raw data if no processed data exist or if processed data exist and have been Fourier transformed in F2 and/or F1. One of them is usually true, i.e. the data have not been processed yet or they have been processed, for example with <strong>xfb</strong>. If, however, the data have been processed with <strong><span class=".index-entry" id="ID0E3DXO"></span>xtrf</strong> with FT_mod = no, they are not Fourier transformed and a subsequent <strong>xfb</strong> will work on the processed data. The <strong>raw</strong> option causes <strong>xfb</strong> to work on the raw data, no matter what. The <strong>proc</strong> option causes <strong>xfb</strong> to work on the processed data. If these do not exist or are Fourier transformed, the command stops and displays an error message. In other words, the option <strong>proc</strong> prevents <strong>xfb</strong> to work on raw data. </li></ul><li value="4"><strong>big/little</strong> </li><ul class="list"><li value="1"><strong>xfb</strong> stores the data in the data <span class=".index-entry" id="ID0E2EXO"></span>byte order (<span class=".index-entry" id="ID0E5EXO"></span>big or <span class=".index-entry" id="ID0EBFXO"></span>little endian) of the computer it runs on e.g. <span class=".index-entry" id="ID0EEFXO"></span>little endian on Windows PCs. Note that TopSpin’s predecessor XWIN-NMR on <span class=".index-entry" id="ID0EHFXO"></span>SGI UNIX workstations stores data in <span class=".index-entry" id="ID0EKFXO"></span>big endian. The byte order is stored in the processing status parameter BYTORDP which can be viewed with <strong>s</strong> <strong>bytordp</strong>. The option <strong>big</strong> or <strong>little</strong> allows to predefine the byte order. This, for example, is used to read processed data with <span class=".index-entry" id="ID0EVFXO"></span>third party software which can not interpret BYTORDP. This option is only evaluated when <strong>xfb</strong> works on the raw data.</li></ul><li value="5"><strong>xdim</strong> </li><ul class="list"><li value="1">Large 2D spectra are stored in the so-called <span class=".index-entry" id="ID0EGGXO"></span>submatrix format. The size of the submatrices are calculated by <strong>xfb</strong> and depend on the size of the spectrum and the available memory. The option <strong>xdim</strong> allows to use predefined submatrix sizes. It causes <strong>xfb</strong> to interpret the F2 and F1 processing parameter XDIM which can be set by entering <strong>xdim</strong> on the command line. The actually used submatrix sizes, whether predefined or calculated, are stored as the F2 and F1 processing status parameter XDIM and can be viewed with <strong>dpp</strong>. Predefining submatrix sizes is, for example, used to read the processed data with <span class=".index-entry" id="ID0ETGXO"></span>third party software which can not interpret the processing status parameter XDIM. This option is only evaluated when <strong>xfb</strong> works on the raw data.</li></ul></ul><p>Normally, <strong>xfb</strong> stores the entire spectral region as determined by the spectral width. You can, however, do a so-called <span class=".index-entry" id="ID0E6GXO"></span>strip transform which means that only a certain region of the spectrum is stored. This can be done by setting the parameters STSR and STSI which represent the <span class=".index-entry" id="ID0EDHXO"></span>strip start and <span class=".index-entry" id="ID0EHHXO"></span>strip size, respectively. They both can take a value between 0 and SI. The values which are actually used can be a little different. STSI is always rounded to the next multiple of 16. Furthermore, when the data are stored in submatrix format (see below), STSI is rounded to the next higher multiple of the <span class=".index-entry" id="ID0ELHXO"></span>submatrix size. Type <strong>dpp</strong> to check this; if XDIM is smaller than SI, then the data are stored in submatrix format and STSI is a multiple of XDIM.</p><p>Depending on size of the processed data and the available computer memory, <strong>xfb</strong> stores the data in <span class=".index-entry" id="ID0EVHXO"></span>sequential or submatrix format. Sequential format is used when the entire dataset fits in memory, otherwise submatrix format is used. <strong>xfb</strong> automatically calculates the submatrix sizes such that one row (F2) of submatrices fits in the available memory. The calculated submatrix sizes are stored in the processing status parameter XDIM (type <strong>dpp</strong>). The next two tables show the alignment of the data points for <span class=".index-entry" id="ID0E4HXO"></span>sequential and submatrix format, respectively. This example shows a dataset with the following sizes: F2 SI = 16, F1 SI = 16, F2 XDIM = 8, F1 XDIM = 4. The storage handling is completely transparent to the user and is only of interest when the data are interpreted by <span class=".index-entry" id="ID0EBIXO"></span>third party software.</p><p> </p><div class="textmodule" id="3278759435"><div class="metalist"></div><figure class="img_80"><img src="../Images/jpg/18014398882579979__Web.jpg" width="646" height="471" /><figcaption>2D data in sequential storage format</figcaption></figure><div class="image"></div><div class="linklist"></div></div><p> </p><div class="textmodule" id="3278754571"><div class="metalist"></div><figure class="img_80"><img src="../Images/jpg/9007199627853707__Web.jpg" width="652" height="467" /><figcaption>2D data in 8*4 submatrix storage format</figcaption></figure><div class="image"></div><div class="linklist"></div></div><p> </p><p>As can be seen in the second table <em>F1 FnMODE</em> of this chapter, the acquisition mode in F1 (FnMODE) determines the Fourier transform mode. Furthermore, FnMODE determines the data storage mode. The description below demonstrates the difference in data storage between a data set with FnMODE = QF and one with FnMODE ≠ QF.</p><h2 class="subheading"><strong>FnMODE = QF</strong> </h2><p><strong>xfb</strong> performs complex (two-quadrant) processing. In F2 the data are acquired phase sensitive, in F1 non-phase sensitive. In the example below, the following parameter settings are used:</p><p>  In F2: TD = 8, SI is 4</p><p>  In F1: TD = 2, SI = 2 </p><p>Furthermore, the following notation is used for individual data points:</p><p><strong>  rncm</strong> : point <em>n</em> of FID <em>m</em>. This point is real in F2 and complex in F1</p><p><strong>  incm</strong> : point <em>n</em> of FID <em>m</em>. This point is imaginary in F2 and complex in F1<strong> </strong></p><h2 class="subheading"><strong>Input F2 processing</strong> (raw data)</h2><figure class="img_80"><img src="../Images/jpg/341239307__en-US__Web.jpg" width="339" height="99" /></figure><p>For F2 processing,<strong> r1c1</strong> <strong>i1c1</strong> is the first complex input point, r2c1 i2c1 the second etc.</p><h2 class="subheading"><strong>Output F2 processing = Input F1 processing</strong></h2><figure class="img_80"><img src="../Images/jpg/341240971__en-US__Web.jpg" width="444" height="129" /></figure><p>Below, the F1 input data are simply redisplayed in vertical order, with the first complex input point in bold. </p><h2 class="subheading"><strong>Input F1 processing</strong></h2><figure class="img_80"><img src="../Images/jpg/341242635__en-US__Web.jpg" width="351" height="136" /></figure><h2 class="subheading"><strong>Output F1 processing</strong></h2><figure class="img_80"><img src="../Images/jpg/341244299__en-US__Web.jpg" width="350" height="135" /></figure><h2 class="subheading"><strong>FnMODE ≠ QF</strong> </h2><p><strong>xfb</strong> performs hypercomplex (four-quadrant) processing. Both in F2 and F1, the data are acquired phase sensitive. In the example below, the following parameters settings are used:</p><p>  In F2: TD = 8, SI is 4</p><p>  In F1: TD = 4, SI = 2 </p><p>Furthermore, the following notation is used for individual data points:</p><ul class="list"><li value="1"><strong>rnrm</strong> : point <em>n</em> of FID <em>m</em>. This point is real in F2 and F1</li><li value="2"><strong>inrm</strong> : point <em>n</em> of FID <em>m</em>. This point is imaginary in F2 and real in F1</li><li value="3"><strong>rnim</strong>: point <em>n</em> of FID <em>m</em>. This point is real in F2 and imaginary in F1</li><li value="4"><strong>inim </strong>: point <em>n</em> of FID <em>m</em>. This point is imaginary in F2 and F1</li></ul><h2 class="subheading"><strong>Input F2 processing (raw data)</strong></h2><figure class="img_80"><img src="../Images/jpg/341245963__en-US__Web.jpg" width="342" height="143" /></figure><p>For F2 processing,<strong> r1r1</strong> <strong>i1r1</strong> is the first hypercomplex input data point, r2r1 i2r1 the second etc.<strong> Output F2 processing = Input F1 processing</strong></p><figure class="img_80"><img src="../Images/jpg/341247627__en-US__Web.jpg" width="444" height="148" /></figure><p>Below, the F1 input data are simply redisplayed, with the first F1 complex input points in bold. </p><h2 class="subheading"><strong>Input F1 processing</strong></h2><figure class="img_80"><img src="../Images/jpg/341249291__en-US__Web.jpg" width="444" height="148" /></figure><h2 class="subheading"><strong>Output F1 processing</strong></h2><figure class="img_80"><img src="../Images/jpg/341250955__en-US__Web.jpg" width="444" height="177" /></figure><h2 class="subheading"><strong>FnMODE = Echo-Antiecho</strong> </h2><p><strong>xfb</strong> performs hypercomplex (four-quadrant) processing. Both in F2 and F1, the data are acquired phase sensitive. In the example below, the following parameters settings are used:</p><p>  In F2: TD = 8, SI is 4</p><p>  In F1: TD = 4, SI = 2 </p><p>Furthermore, the following notation is used for individual data points:</p><ul class="list"><li value="1"><strong>rnrm</strong> : point <em>n</em> of FID <em>m</em>. This point is real in F2 and F1</li><li value="2"><strong>inrm</strong> : point <em>n</em> of FID <em>m</em>. This point is imaginary in F2 and real in F1</li><li value="3"><strong>rnim</strong>: point <em>n</em> of FID <em>m</em>. This point is real in F2 and imaginary in F1</li><li value="4"><strong>inim </strong>: point <em>n</em> of FID <em>m</em>. This point is imaginary in F2 and F1</li></ul><h2 class="subheading"><strong>Input F2 processing (raw data)</strong></h2><figure class="img_80"><img src="../Images/jpg/341252619__en-US__Web.jpg" width="356" height="144" /></figure><p>For F2 processing,<strong> r1r1</strong> <strong>i1r1</strong> is the first hyper complex input data point, r2r1 i2r1 the second etc.</p><h2 class="subheading"><strong>Output F2 processing = Input F1 processing</strong></h2><p> </p><figure class="img_80"><img src="../Images/jpg/341254283__en-US__Web.jpg" width="450" height="262" /></figure><p>Below, the F1 input data are simply redisplayed, with the first F1 complex input points in bold.</p><h2 class="subheading"><strong>Input F1 processing</strong></h2><figure class="img_80"><img src="../Images/jpg/2349172363__en-US__Web.jpg" width="387" height="270" /></figure><h2 class="subheading"><strong>Output F1 processing</strong></h2><figure class="img_80"><img src="../Images/jpg/2349174539__en-US__Web.jpg" width="388" height="345" /></figure><p>Note that:</p><ul class="list"><li value="1">For FnMODE ≠ QF, zero filling once in F1 is done when SI = TD. For FnMODE = QF, zero filling once in F1 is done when SI = 2*TD. </li><li value="2">FnMODE = QF is normally used on magnitude or power data. For this purpose, the F1 processing parameter PH_mod must be set to MC or PS, respectively. Note that in these cases, no imaginary data are stored after F1 processing.</li><li value="3">FnMODE = Echo-Antiecho is equivalent to FnMODE = States, except that two consecutive FIDs (rows of the 2D raw data) are linearly combined according to the following rules: </li><ul class="list"><li value="1">re0 = -im1 - im0</li><li value="2">im0 = re1 + re0</li><li value="3">re1 = re1 - re0</li><li value="4">im1 = im1 - im0</li></ul><li value="4">xfb n does not store imaginary data after F1 processing.</li></ul><h2 class="subheading">2D PROCESSING OF 3D DATA</h2><p><strong>xfb</strong> can also be used to process one 2D <span class=".index-entry" id="ID0E5WXO"></span>plane of a 3D spectrum. This can be a plane in the F3-F2 or in the F3-F1 direction. The output 2D data are stored in a separate<em> procno</em>. When the current dataset is a 3D, <strong>xfb</strong> will prompt you for the plane axis direction, the plane number, the output<em> procno</em> and, if applicable, for the permission to overwrite existing data. Alternatively, you can enter this information as arguments on the command line, for example: </p><p><strong>  xfb s23 17 2 y</strong> </p><p>Will read the F3-F2 plane number 17 and store it under procno 2, overwriting possibly existing data. Furthermore, you can use the <strong>nodisp</strong> argument to prevent opening/displaying the destination dataset, e.g.:</p><p><strong>  xfb s23 17 2 y nodisp</strong> </p><p>For 2D processing of 3D echo-antiecho (EA) data the option <strong>eao</strong> is available. This option ensures EA calculation when:</p><ul class="list"><li value="1">the 3D raw data are EA in either F2 or F1 (the acquisition status parameter FnMODE = Echo-Antiecho in F2 or F1, respectively)</li><li value="2">the processed plane does not include the EA direction</li></ul><p>For example, to process F2-F3 plane 17 of a 3D dataset which is EA in F1, enter:</p><p><strong>  xfb eao s23 17 2 y</strong> </p><p>If you omit the <strong>eao</strong> option, the plane is still processed but no EA calculation is done. Using the <strong>eao</strong> option allows to determine the correct phase values for EA data or compare the processed plane with a plane extracted from a 3D processed data. Note that if the processed plane includes the EA direction, or if the 3D data are not EA in any direction, the option <strong>eao</strong> has no effect.</p><p>When executed on a dataset with 3D raw data but 2D processed data (usually a result of a previous 2D processing command on that 3D dataset), <strong>xfb</strong> takes one argument:</p><p><strong>  xfb &lt;plane&gt;</strong> </p><p>Process the specified plane and store it under the current<em> procno</em>.</p><p><strong>  xfb same</strong> </p><p>Process the same plane as the previous processing command and store it under the current<em> procno</em>. The <strong>same</strong> option is automatically used by the AU program macro XFB. When used on a regular 2D dataset (i.e. with 2D raw data), it has no effect.</p><h2 class="subheading">INPUT PARAMETERS </h2><p><strong>F2 and F1 parameters</strong></p><p>Set from the <strong>ftf</strong> dialog box, with <strong>edp</strong> or by typing <strong>bc_mod</strong>, <strong>bcfw</strong> etc.</p><p>BC_mod - FID baseline correction mode</p><p>  BCFW - filter width for BC_mod = sfil or qfil</p><p>  COROFFS - correction offset for BC_mod = spol/qpol or sfil/qfil</p><p>ME_mod - FID linear prediction mode</p><p>  NCOEF - number of linear prediction coefficients </p><p>  LPBIN - number of points for linear prediction </p><p>  TDoff - number of raw data points predicted for ME_mod = LPb*</p><p>WDW - FID window multiplication mode</p><p>  LB - Lorentzian broadening factor for WDW = em or gm</p><p>  GB - Gaussian broadening factor for WDW = gm, sinc or qsinc</p><p>  SSB - Sine bell shift for WDW = sine, qsine, sinc or qsinc</p><p>  TM1, TM2 - limits of the trapezoidal window for WDW = trap</p><p>PH_mod - phase correction mode</p><p>  PHC0 - zero order phase correction value for PH_mod = pk</p><p>  PHC1 - first order phase correction value for PH_mod = pk</p><p>SI - size of the processed data</p><p>STSR - strip start: first output point of strip transform</p><p>STSI - strip size: number of output points of strip transform</p><p>TDeff - number of raw data points to be used for processing </p><p>TDoff - first point of the FID used for processing (default 0)</p><p>FCOR - first (FID) data point multiplication factor (0.0-2.0, default 0.5)</p><p>REVERSE - flag indicating to reverse the spectrum</p><p>XDIM - <span class=".index-entry" id="ID0EK2XO"></span>submatrix size (only used for the command <strong>xfb</strong> <strong>xdim</strong>)</p><p>Set by the acquisition, can be viewed with <strong>dpa</strong> or by typing <strong>s</strong> <strong>td</strong> :</p><p>TD - time domain; number of raw data points</p><p> </p><p><strong>F2 parameters</strong></p><p>Set from the <strong>ftf</strong> dialog box, with <strong>edp</strong> or by typing <strong>pknl</strong> :</p><p>PKNL - group delay compensation (Avance) or filter correction (A*X)</p><p>Set by the acquisition, can be viewed with <strong>dpa</strong> or by typing <strong>s</strong> <strong>aq_mod</strong>.:</p><p>AQ_mod - acquisition mode (determines the Fourier transform mode)</p><p>BYTORDA - byteorder or the raw data</p><p>NC - normalization constant</p><p> </p><p><strong>F1 parameters</strong></p><p>Set by the acquisition, can be viewed with <strong>dpa</strong> or by typing <strong>s</strong> <strong>fnmode</strong> :</p><p>FnMODE - F1 Acquisition transform mode</p><p>Set by the user with <strong>edp</strong> or by typing <strong>mc2</strong> :</p><p>MC2 - FT mode in F1 (only used if F1-FnMODE = undefined)</p><h2 class="subheading">OUTPUT PARAMETERS </h2><p><strong>F2 and F1 parameters</strong></p><p>Can be viewed with <strong>dpp</strong> or by typing <strong>s</strong> <strong>si</strong>, <strong>s</strong> <strong>tdeff</strong> etc.:</p><p>SI - size of the processed data</p><p>TDeff - number of raw data points that were used for processing</p><p>FTSIZE - Fourier transform size</p><p>STSR - strip start: first output point of strip transform </p><p>STSI - strip size: number of output points of strip transform</p><p>XDIM - submatrix size</p><p>FT_mod - Fourier transform mode</p><p> </p><p><strong>F2 parameters</strong></p><p>Can be viewed with <strong>dpp</strong> or by typing <strong>s</strong> <strong>ymax_p</strong>, <strong>s</strong> <strong>ymin_p</strong> etc.:</p><p>YMAX_p - maximum intensity of the processed data</p><p>YMIN_p - minimum intensity of the processed data</p><p>S_DEV - standard deviation of the processed data</p><p>NC_proc - intensity scaling factor</p><p>BYTORDP - byte order of the processed data</p><h2 class="subheading">INPUT FILES</h2><p><em>&lt;dir&gt;/data/&lt;user&gt;/nmr/&lt;name&gt;/&lt;expno&gt;/</em></p><p><em>  ser</em> - raw data (input if <em>2rr</em> does not exit or is Fourier transformed)</p><p><em>&lt;dir&gt;/data/&lt;user&gt;/nmr/&lt;name&gt;/&lt;expno&gt;/pdata/&lt;procno&gt;/</em></p><p><em>  2rr</em> - real processed 2D data (input if it exists but is not Fourier transformed)</p><p><em>  proc</em> - F2 processing parameters</p><p><em>  proc2</em> - F1 processing parameters</p><p><em>  acqus</em> - F2 acquisition status parameters</p><p><em>  acqu2s</em> - F1 acquisition status parameters</p><div class="safety safety-type-note safety-severity-note"><div class="safety-header">NOTE</div><div class="safety-body"><div class="row"><div class="col-sm-2 safety-symbol"><img src="../safety/note_NoteIcon.png" /></div><div class="col-sm-10"><p class="safety-consequence">Note that if <em>2rr</em> is input, then <em>2ir</em> and <em>2ri</em> can also be input, depending on the processing status of the data.</p></div></div></div><div class="safety-footer"></div></div><h2 class="subheading">OUTPUT FILES</h2><p><em>&lt;dir&gt;/data/&lt;user&gt;/nmr/&lt;name&gt;/&lt;expno&gt;/pdata/&lt;procno&gt;/</em></p><p><strong>For FnMODE  QF:</strong></p><p><em>  2rr</em> - real processed 2D data </p><p><em>  2ir</em> - second quadrant imaginary processed data </p><p><em>  2ri</em> - third quadrant imaginary processed data </p><p><em>  2ii</em> - fourth quadrant imaginary processed data</p><p><strong>For FnMODE = QF:</strong></p><p><em>  2rr</em> - real processed 2D data </p><p><em>  2ii</em> - second quadrant imaginary processed data</p><p><strong>For all values of FnMODE:</strong></p><p><em>  procs</em> - F2 processing status parameters</p><p><em>  proc2s</em> - F1 processing status parameters</p><p><em>  auditp.txt</em> - processing audit trail</p><h2 class="subheading">USAGE IN AU PROGRAMS</h2><p>XFB</p><p>If you want to use XFB with an option, you can do that with <span class=".index-entry" id="ID0EDDYO"></span>XCMD, e.g.</p><p>XCMD("xfb raw")</p><h2 class="subheading">SEE ALSO</h2><p><a style="color:#3195CA;" href="3278722955.html">xf1</a>, <a style="color:#3195CA;" href="3278741003.html">xf2</a>, <a style="color:#3195CA;" href="3278731275.html">xfbm, xf2m, xf1m</a>, <a style="color:#3195CA;" href="3278764299.html">xfbp, xf2p, xf1p</a>, <a style="color:#3195CA;" href="3278736139.html">xfbps, xf2ps, xf1ps</a>, <a style="color:#3195CA;" href="3278785035.html">xtrf, xtrf2</a></p><div class="image"></div><div class="image"></div><div class="image"></div><div class="image"></div><div class="image"></div><div class="image"></div><div class="image"></div><div class="image"></div><div class="image"></div><div class="image"></div><div class="image"></div><div class="image"></div><div class="image"></div><div class="image"></div><div class="image"></div></div><div class="container"><footer><p class="text-muted">@ Bruker Corporation 2023</p></footer></div></div><div class="schema-navbar" id="navbar" role="navigation"><button class="schema-navbar-toggle visible-sm visible-xs" id="sidebar-toggle"><span class="schema-glyph schema-glyph-menu"></span></button><a class="schema-navbar-brand" href="index.html"><img class="schema-navbar-logo" src="../assets/img/logo_white.svg" /></a><button class="btn btn-default dropdown-toggle schema-navbar-toggle mobile-hidden-xs mobile-hidden-sm" style="margin-top:20px;" id="language-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span class="schema-glyph schema-glyph-more_vert" style="top:0;"></span></button><ul class="dropdown-menu" id="language-dropdown"><li class="dropdown-header hidden-md hidden-lg"></li><li class="hidden-md hidden-lg"><a href="index.html">Home</a></li><li class="dropdown-header">Language</li><li class="langMenuItem checked" data-value="en-US"><a href="../en-US/3278749323.html">us-english</a></li></ul><div id="navbar-search"><form class="schema-navbar-search hidden-xs pull-right" role="search" action="search.html"><input type="text" name="q" autocomplete="search2662718347" placeholder="Search" results="10" /></form></div><ul class="navbar-structure-pages hidden-sm hidden-xs "><li class="schema-home-text"><a href="index.html">Home</a></li></ul><button class="navbar-toggle schema-navbar-toggle visible-xs" data-toggle="collapse" data-target="#search-collapse"><span class="schema-glyph schema-glyph-search"></span></button><form class="collapse hidden-sm hidden-md hidden-lg" id="search-collapse" role="search" action="search.html"><input type="text" name="q" autocomplete="search2662718347" placeholder="Search" results="10" /></form></div></div></div><script type="text/javascript" charset="utf-8" src="js/treedata.json"></script><script src="../assets/js/00-jquery.min.js"></script><script src="../assets/js/01-bootstrap.min.js"></script><script src="../assets/js/02-modernizr.custom.js"></script><script src="../assets/js/03-jquery-tree.js"></script><script src="../assets/js/04-jquery.mmenu.oncanvas.min.js"></script><script src="../assets/js/05-jquery.mcustomscrollbar.min.js"></script><script src="../assets/js/06-jquery-scrollbars.min.js"></script><script src="../assets/js/18-schema-common-core.min.js"></script><script src="../assets/js/19-schema-common-search.js"></script><script src="../assets/js/20-bootstrap-schema.js"></script></body></html>